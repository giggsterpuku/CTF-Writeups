################################ Write-Up ##################################
# Challenge: Secure Login
# Category: Binary
# Points: 50
# Description: My login is, potentially, and I don't say this lightly, if you know me you know that's the truth, it's truly, and no this isn't snake oil, this is, no joke, the most secure login service in the world (source). Try to hack me at /problems/2021/secure_login on the shell server.
# Hint: Look into how strcmp works and how that fits in with what /dev/urandom returns.
# Author: kmh
#
# This chall was p fun to learn about how strcmp worked, and I 
# actually used it to solve the Sanity Checks chall too. Using the 
# hint, I looked up what strcmp() does: it does comparison checks on 
# two strings, which in this case was your input and the randomly 
# generated bytes that are in /dev/urandom, until it reaches a null 
# byte, which would be used in its last comparison. Looking up 
# /dev/urandom, its contents are generated from the actions going on 
# in the hardware, which makes it a PRNG. I thought initially I had 
# to somehow emulate the hardware actions somehow so that it would 
# be similar to the conditions of the server so that the output for 
# /dev/urandom would be the same so I can snatch the flag, but then 
# it would be too difficult. But then I realized: I can just
# bruteforce my way. I could just keep the same input until it
# matched with the password string randomly generated. I know it
# would theoretically take too long, BUT NOT IF THE INPUT IS
# A SINGLE NULL BYTE. That way, the comaprison would be quicker,
# since one comparison has to be made. So, all I have to do is
# keep inputting that null byte as input until it matches the first
# byte in /dev/urandom, and then it would get me the flag. Here is a
# tiny one-liner script I made to do it:
# while true; do python -c 'print("\x00")' | ./login | grep actf; done
#
# Flag: actf{if_youre_reading_this_ive_been_hacked}
# Solved by: Ryan Nguyen

