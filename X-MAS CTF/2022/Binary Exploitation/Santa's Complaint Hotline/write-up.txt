Challenge: Santa's Complaint Hotline
Category: Binary Exploitation
Description:
Have you ever wanted to have a place where you could express your biggest concerns about this year's X-MAS but didn't
have a toll-free (taxes may apply) telephonic service at your disposal? Well, this year Santa took care of that!


The exploit to apply here was a ret2libc attack, which is something I know, but I couldn't exactly identify the exploit
from just staring at the decompiled code in Ghidra at first. Here was the decompiled main() function:

undefined8 main(void)

{
  int iVar1;
  FILE *__stream;
  char local_810 [1024];
  char acStack1040 [1032];
  
  setvbuf(stdin,(char *)0x0,2,0);
  setvbuf(stdout,(char *)0x0,2,0);
  __stream = fopen("/dev/null","w");
  setbuf(__stream,acStack1040);
  puts("Write all the complaints you have about Santa, they will be merrily redirected to /dev/null "
      );
  while( true ) {
    iVar1 = memcmp(local_810,"done",4);
    if (iVar1 == 0) break;
    memset(local_810,0,512);
    fgets(local_810,512,stdin);
    fwrite(local_810,1,512,__stream);
  }
  return 0;
}

So, to me it did not seems like a bof exploit chall b/c I thought it seemed like any buffers could be overflown. fgets()
takes in bytes that are less than those in the buffer you are supplied for your input, and it dumps it into "/dev/null"
using fwrite(). However, when I ran it and spammed some input, I noticed that if I entered at least 2 lines of data and
typed in "done" to finish my input, the binary segfaults. Re-examining the code, I then took notice of the stream buffer
attached to "/dev/null," and I thought that maybe the fwrite() commands do not clear any of the contents from the
previous calls to fwrite(), so maybe the data piled on eventually can lead to a buffer overflow since each time
fwrite() is called, 512 bytes of the buffer holding our input is written into the stream buffer. Do that two times, and
that's 1024 bytes written in, and by the third time, 512 * 3 = 1536 bytes are written into it, thus overflowing the
buffer and the registers below it on the stack. To test the theory, I made a ROP chain to leak out the puts() address
and calculated the offset and payload to make it work, and it turned out to work! From there, I struggled with
remembering how to do ret2libc and debugging my exploit, and boom, there's a shell.


Flag: X-MAS{H07l1n3_Buff3r5_t00_5m4ll}
Solved by giggsterpuku 24 hrs in
