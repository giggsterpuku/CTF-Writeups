Challenge: Krampus' Greetings
Category: Binary Exploitation
Description: Krampus wanted to redeem himself for all the bad he has done across the years. He wrote you small program
to craft the best Christmas greetings. He might need to brush up his C++ skill though.

I only took a small glance at the chall but did not do much with it until the CTF ended. However, I was able to figure
out that the exploit to perform is a bof. In the source code (main.cpp), you can see that there is a Flag() function
that is not called in the program at all, but it spawns a shell. The program starts off prompting the user for a single
character, and after it preompts for a symbol code. For the symbol code, the program tallies all the number of times
each character in the SYMBOLS constant string literal shows up in the code. With those tallies, the program then
calculates the number of times the single character the user supplied is going to be copied into an output buffer that
will be printed out. That number is going to be calculated as a somewhat of a base 3 number from the tallies except
tha tallies/digits can be 3 at max, and each character in SYMBOLS represents a digit in said number ("A" is 3^0 = 1, "B"
is 3^1 = 3, "C" is 3^2 = 9, etc). Then, the program will prompt for the message you want to encase within the lines of
the repeated single character. Here, I knew that the the idea to be able to exploit the code was to use a symbol code
to basically be padding to fill the output buffer and an extra 16 bytes that is in the stack between the buffer and the
4-bytes i and outputCursor integers, and from there I would have to fill the integer memory with sensible values (any
number less than 2312 (output buffer size) + 16 (bytes between output buffer and integer i) - 1 (for the newline
character) = 2327 for outputCursor at least) and overwrite the rbp and make a ROP chain with a ret instruction with the
address to the Flag() function so that the system() call does not segfault. The main constraint that I thought was there
was that the code that would yield the max number of bytes to write the single character multiple times will not be able
to overflow the buffer with the characters in the SYMBOLS string liters. However, a person who solved the chall said it
is possible, and I learned that every string literal ends with a null byte, so in the range-based for loop that
calculates the tallies for each character's occurrence in the code, it also counts the null byte's occurrences, thus
increasing the number calculated significantly enough so that the buffer can be overflown. From there, I was able to
craft the exploit and spawn the shell on the remote server.

Note to self: Check the disassembly of the binary to see where the local variables lie in the stack.

Flag: X-MAS{kR4Mpu5_5eND5_h15_9ReE71N95_4nd_Re94rD2}
Reviewed by giggsterpuku
