Challenge: Naughty List
Category: Binary Exploitation
Description: PinkiePie managed to get on the Naughty List this year. Use your skills to get him out of this situation
and he might reward you!

Man, after two of wondering if this code was even exploitable at all, I finally found the exploit (hella pumped right
now WOOOOOOOOOOOOOOOOOOOOOOOOOOOOO!!!). The chall only gave one file: the C++ source code to the binary running on the
remote server. I did not know very much about C++, so I kinda had to learn a lot how the code worked using a butt ton of
C++ documentation online to understand what was going on. Basically, the binary takes in an integer to select what you
want to do in the binary. The first mentioned option is to attempt to get the flag, and in order to do so, the program
will iterate through the unordered map initialized at the start containing PinkiePie's name in it as a key value to see
if the name shows up within the first 16 items (or all if the number of items is less than 16). The second option is to
check whether or not a key value in the map that you supply has a corresponding value to it that is not an empty string
(well at first that was the ONLY thing I thought it did, hint hint). The third option was to create an item in the map,
with its key value being the input you supply as well as "Naughty" as its correspoding value. However, if the size of
map is equal to the max number of items that there SHOULD be at max (16, again another hint hint), you cannot insert
another item. I thought up of a lot of exploits to try out, and many of them are wrong. I tried to make a bof but I
learned that std::string basically gives all the space you need to make your string, so that was not plausible. I
thought of doing an integer overflow/underflow, but that did not work since the C++ program just truncates the number
you input. I learned that when listing out contents of the unordered map, the order is randomized, so the items would be
coming out at random, and I thought the exploit was to used that to maybe delay the code from scanning the PinkiePie
entry in the map, but that made no sense. However, after long hours of Googling C++ vulnerability articles and staring
at YouTube videos on C++ undefined behavior, I finally thought up of a search: could we possible forge an entry in the
map to maybe bypass that max-etries limit and create more entries. I Googled something to the lines of that, and I
found a Stack overflow article mentioning this key functionality of the construction operator of an unordered map in
C++ that I later noticed in its documentation: the map inserts an entry if the key does not exist when
<insert unordered_map name>[<key name>] is called. Looking back at the code, I realized that THERE IS a bug in the code
that implements this functionality, and it comes from that second option. It calls this function with the following
code:

bool is_naughty(const std::string &name) { return !(naughty_list[name] == ""); }

When naughty_list[name] is called, if the name supplied DOES NOT have an entry in the map already, it is then made right
before the comparision (corresponding value is an empty string according to the C++ documentation). That means that
we can bypass that max-entries limit by using the second option again and again and making several entries by supplying
different names (you cannot reuse the same name!). So, my exploitation script is styled so that it makes as many entries
as needed so that the PinkiePie's name is outside the bounds of the first 15 elements that are checked by the first
option, and the exploit works. It has been consistently finished when there are 30 items in the map for some reason
though, don't know why.

Flag: X-MAS{PiNKi3pi3_wiLl_n07_r3C3IV3_C04l_7hI5_y34R}
Solved by giggsterpuku 5 days in
