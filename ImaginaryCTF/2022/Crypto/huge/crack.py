#!/usr/bin/env python3

from Crypto.Util.number import *
import sympy
import math

n = 257827703087398016057355158654193468564980243813004452658087616586210487667215030370871398983230710387803731676134007721137156696714627083072326445637415561591372586919746606752675050732692230618293581354674196658443898625965651230501721590806987488038754683843111434873697465691139129703835890867256688046172118591
e = 65537
ct = 194667317703687479298989188290833629421904543231503224641743768867721632949682167895699280370759100055314992068135383846690184090232092994595979623784341194946153538127175310278245722299688212621004144260665233469561373125699948009903943019071999887294005117156960295183926108287198987970959145603429337056005819069
n_factors = {521 : 2 , 541 : 1 , 563 : 1 , 569 : 2 , 571 : 1 , 577 : 2 , 587 : 2 , 599 : 1 , 601 : 3 , 607 : 1 , 613 : 1 , 617 : 3 , 619 : 2 , 631 : 1 , 647 : 3 , 659 : 3 , 661 : 1 , 673 : 2 , 677 : 3 , 683 : 1, 691 : 4 , 701 : 4 , 709 : 2 , 719 : 1 , 739 : 1 , 743 : 1 , 761 : 1 , 769 : 2 , 797 : 6 , 809 : 4 , 811 : 1 , 821 : 1 , 827 : 4 , 829 : 1 , 839 : 2 , 853 : 1 , 857 : 1 , 859 : 2 , 863 : 2 , 877 : 2 , 881 : 1 , 883 : 1 , 887 : 1 , 911 : 1 , 919 : 1 , 937 : 2 , 947 : 5 , 967 : 2 , 971 : 1 , 977 : 2 , 983 : 1 , 991 : 3 , 997 : 1 , 1009 : 3 , 1013 : 1 , 1019 : 3 , 1021 : 1}

def phi(prime_num, power): # Basic Euler totients, multiplicative property not coded b/c it's unnecessary
	ans = 1
	if power > 1:
			return pow(prime_num, power) - pow(prime_num, power - 1)
	else:
			return prime_num - 1
	return ans

def c_lambda(): # Compiles all the different Charmichael totients of each factor by their respective powers
	lambda_ns = []
	for i in n_factors:
		lambda_ns.append(phi(i, n_factors[i]))
	return lambda_ns

#print(c_lambda()) <-- used to print out the individual Charmichael totients to past into the script
#math.lcm() was only available in python3.9 and later so I ran uncommented part of the next line in python3.10
c_lambda = 1082664081224801721979182938644730954162050929334701140062405741450107789010173736755679559528900584568755273065822774713673198122259497547687853309452959626034188511262701472613537946090509907383553917398494534400 #math.lcm(270920, 540, 562, 323192, 570, 332352, 343982, 598, 216720600, 606, 612, 234504424, 382542, 630, 270421414, 285756898, 660, 452256, 309830404, 682, 227658165990, 241130470700, 501972, 718, 738, 742, 760, 590592, 255979198388910572, 427815904232, 810, 820, 467193267758, 828, 703082, 852, 856, 737022, 743906, 768252, 880, 882, 886, 910, 918, 877032, 760835997827026, 934122, 970, 953552, 982, 972260190, 996, 1026225648, 1012, 1057051498, 1020)
#print(c_lambda)

d = sympy.mod_inverse(e, c_lambda)
m = pow(ct, d, n)
flag = long_to_bytes(m)
print(flag)
