Challenge: stack cache
Category: Binary Exploitation
Description: Undefined behaviours are fun. It looks like Dr. Oswal allowed buffer overflows again. Analyse this program to identify how you can get to the flag. You can view source here. And connect with it using nc saturn.picoctf.net 50196
Hints:
	-1: Maybe there is content left over from stack?
	-2: Try compiling it with gcc and clang-12 to see how the binaries differ

This one was really satisfying to solve after 3 days of solid struggle, but the result was a tad underwhelming.
Fisrt thinking about the chall and hints, I thought that ther were referring to a security feature called
SafeStack where the stack is split into two separate ones to separate the ret addrs and local variables to
buffers and other local vars that were easilt susceptible to memory corruption, but this was not the case as I
reaized that there were no optimisations made on the binary when compiled in Clang. I searched up differences
between GCC and Clang, but nothing pertaining to the stack showed up on Google concerning thier differences.
Analyzing the binary, I thought that a b0f wouldn't work on the binary bc of a canary as spotted by checksec, but
that was not the case at all. I thought up another vuln, and I observed that the stack had memory addresses that
shifted downwards (towards high mem addrs), and the stuff in said higher memory addrs were no wiped out, so I
thought up of making the payload bypass a canary check by keeping the eip of the program at that place, and since
I found that vuln() reruns when you put in any 14 chars when prompted, I though of making that be padding and
putting in the win() addr to get the exploit. It worked, but it didn't show the flag. That's when I realized that
it wasn't even supposed to print it. It just processed it into the stack and exited. ._. Then, I looked up some
unidentified behaviors in C and I thought of using a ROP chain with the previous padding and "canary bypass" to
call win() and then call UnfinishedConstruction(), realizing that the leftover content on the stack would be
printed out by UnfinishedConstruction() bc it initializes a bunch of variables, and when it prints them out,
the content that is printed is the memory that was in their places in the stack before they were initialized. So,
by calling win() first, the flag is left on the stack, and then UnfinishedConstruction() will print it in its
variables. Once that worked locally, I got the flag on the remote server. After solving the chall, I wondered if
I even needed to implement the canary bypass, and it turns out I didnt need to :frog:. I just needed to make a
simple ROP chain with the padding + win + UnfinishedConstruction to get it. smol or beeg bren, idk. I just got
the flag.

Flag: picoCTF{Cle4N_uP_M3m0rY_255ce767}
Points: 400
SOlved by giggsterpuku 10 days into comp
