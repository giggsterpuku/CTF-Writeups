###Challenge: babygame02

###Category: Binary Exploitation

###Description: Break the game and get the flag. Welcome to BabyGame 02! Navigate around the map and see what you can find!

####Hints:

####1.
#### * Use 'w','a','s','d' to move around.

#### * There may be secret commands to make your life easy.

Apparently I was close on completing the exploit of the challenge, but unfortunately I was not able to figure the nuances of my payload that got the program to error. Like babygame01, the goal of the challenge is to overwrite memory by using a write primitive with the direction keys. The code in move_player() for the binary provided is similar to that of babygame01's:

```c
void move_player(astruct_1 *player,char input,int map_start_addr)

{
  int iVar1;
  
  if (input == 'l') {
    iVar1 = getchar();
    player_tile = (undefined)iVar1;
  }
  if (input == 'p') {
    solve_round(map_start_addr,player);
  }
  *(undefined *)(player->y_pos * 90 + map_start_addr + player->x_pos) = '.';
  if (input == 'w') {
    player->y_pos = player->y_pos + -1;
  }
  else if (input == 's') {
    player->y_pos = player->y_pos + 1;
  }
  else if (input == 'a') {
    player->x_pos = player->x_pos + -1;
  }
  else if (input == 'd') {
    player->x_pos = player->x_pos + 1;
  }
  *(undefined *)(player->y_pos * 90 + map_start_addr + player->x_pos) = player_tile;
  return;
}
```

The buffer containing the map is placed below the other variables on the stack (on top being the lower address and the bottom being the higher addresses). There are no bounds checks to see if the x or y-coordinates are negative, so we are able to overwrite lower addresses like in babygame01. This time, instead of overwriting a local variable (i.e. the flag attribute of the player), the goal is to overwrite the return address. Looking into GDB and doing some calculations, I figured that the offset between the map buffer and the return address is 39. In addition, comparing the address in the EIP and that of the win() address (0x08049474), it seems that due to no PIE security implementation, the EIP holds an address of where the binary code is stored (i.e. an instruction in move_player()), so all I needed to do was to partially overwrite the return address by one byte. 

However, getting to the return address was what I struggled with the most. I knew that renaming the map icon representing the player with a character resembling the last byte in the win() address (0x74, or 't' in ASCII). Getting to the return address, was the main problem. My first approach was to get there by spamming 39 "a"'s but then I realized that doing so with corrupt other variables and cause the program to segfault. The next idea was to first jump past all the other variables with 5 "w"'s and then move my way over to the return address with "d"'s, but that would also do a lot of overwriting, and the program seemed to not increment the address to overwrite after I put in a caertain amount of "d"'s. Looking at a write-up, it seemed what I was doing wrong was setting up the order in which I input the "w"'s and "d"'s. I should have typed in the "d"'s first and them the "w"'s to minimize the amount of memory I would overwrite and only overwrite 1 byte in the return address. With that, I finally found that my payload worked. This is the final payload: ltdddddddddddddddddddddddddddddddddddddddddddddddwwwww

###Flag: picoCTF{gamer_jump1ng_4r0unD_8d141e10}

Reviewed by giggsterpuku
