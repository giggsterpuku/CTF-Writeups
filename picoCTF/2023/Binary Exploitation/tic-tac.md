## Challenge: tic-tac

## Category: Binary Exploitation

### Description: Someone created a program to read text files; we think the program reads files with root privileges but apparently it only accepts to read files that are owned by the user running it. ssh to saturn.picoctf.net:[PORT], and run the binary named "txtreader" once connected.

Logging onto the server, we can see the source code of the txtreader executable:

```c++
#include <iostream>
#include <fstream>
#include <unistd.h>
#include <sys/stat.h>

int main(int argc, char *argv[]) {
  if (argc != 2) {
    std::cerr << "Usage: " << argv[0] << " <filename>" << std::endl;
    return 1;
  }

  std::string filename = argv[1];
  std::ifstream file(filename);
  struct stat statbuf;

  // Check the file's status information.
  if (stat(filename.c_str(), &statbuf) == -1) {
    std::cerr << "Error: Could not retrieve file information" << std::endl;
    return 1;
  }

  // Check the file's owner.
  if (statbuf.st_uid != getuid()) {
    std::cerr << "Error: you don't own this file" << std::endl;
    return 1;
  }

  // Read the contents of the file.
  if (file.is_open()) {
    std::string line;
    while (getline(file, line)) {
      std::cout << line << std::endl;
    }
  } else {
    std::cerr << "Error: Could not open file" << std::endl;
    return 1;
  }

  return 0;
}
```

Here, it seems that the executable does a check to make sure that the user running the file owns the file it is about to read. Once it does, it then opens the file. However, the vulnerability lies in the idea that the executable trusts that from the time it does that to the time the file is opened, the file is not changed. Thus, this leads to a race condidtion, which can be taken advantage of since there is a slim time gap between the time of check to the time of the file's usage. This scenario is called TOCTOU as I have come to learn. The exploit to the challeng can be done a couple ways, both having to do with making an arbitrary file (although I think there may be more):

1. In the time gap, swap the names of the flag.txt file and the file you made so that at the time of usage it opens up the flag file instead of your file.

OR

2. In the time gap, turn your file into a symlink so that when your file it opened, it points to the flag.txt file so that you can get the flag.

I went with the first option, and to do it I used the code provided by LiveOverflow and compiled it: [gistfile1.txt](https://gist.github.com/LiveOverflow/590edaf5cf3adeea31c73e303692dec0). Next, I opened up two SSH sessions: in one I ran the executable swapping the names of the files constantly, and in the other one I repeatedly ran the txtreader executable. This does not work many times, as the timing is a bit off, but on many other times it does, getting the flag to be read.

### Reference: [1](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use)

### Flag: picoCTF{ToctoU_!s_3a5y_107916f2}

Solved by giggsterpuku
