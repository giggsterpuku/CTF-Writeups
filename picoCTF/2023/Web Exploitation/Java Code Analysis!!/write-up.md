##Challenge: Java Code Analysis!?!

##Category: Web Exploitation

##Description: BookShelf Pico, my premium online book-reading service. I believe that my website is super secure. I challenge you to prove me wrong by reading the 'Flag' book!

###Hints:

####1. Maybe try to find the JWT Signing Key ("secret key") in the source code? Maybe it's hardcoded somewhere? Or maybe try to crack it?

####2. The 'role' and 'userId' fields in the JWT can be of interest to you!

####3. The 'controllers', 'services' and 'security' java packages in the given source code might need your attention. We've provided a README.md file that contains some documentation.

####4. Upgrade your 'role' with the new (cracked) JWT. And re-login for the new role to get reflected in browser's localStorage.

Opening the website, I notice that upon logging in I was given the role of a Free user with not a lot of power: just being able to read the free book and change my user settings. I then looked at the source code. The meat of the exploit lied within the JwtService.java and SecretGenerator.java (from the unzipped contents you can find it in src/main/java/io/github/nandandesai/pico/security). From JWTService.java, I found that the web server uses JSON Web Tokens (a.k.a. JWT) to verify the role and corresponding user ID of the user. Thus, the website is vulnerable to what seems to be the intended exploit: **JWT forgery**. The server seems to trust whatever JWT the website user supplies, and because of that trust it can be exploited. I supplied a JWT I made to become the admin and do what hint 4 suggests. I used [this article](https://infosecwriteups.com/attacking-json-web-tokens-jwts-d1d51a1e17cb) to help me learn how to conduct the forgery attack.

The first step was to figure out the format of the JWT. According to the article, there are 3 parts: the header, the payload, and the signature, each separated by a period in the token. The header and payload are Base64-encoded JSON pieces of information. The header supplies the type of data in the payload and algorithm used to create the signature. To verify, I checked out the JWT made to the server when I logged into the website by opening up the Chrome Web Development Tools and going to the Applocation window and under Local Storage and clicked the website link under it (the JWT is listed as the auth-token). Decoding the header and payload, they look like this (respectively):

>{"typ":"JWT","alg":"HS256"}

>{"role":"Free","iss":"bookshelf","exp":1680664877,"iat":1680060077,"userId":1,"email":"user"}

For the payload, I edited it so that the admin role and userId are reflected (the userId corresponding to the role can be found in ):

>{"role":"Admin","iss":"bookshelf","exp":1680664877,"iat":1680060077,"userId":4,"email":"admin"}

The header stays the same in the forged cookie, and the payload above is used to make the second part of the JWT. The last part is to make a HMAC signature for the JWT, which is uniquely made with the header, a period, and the payload concatenated sequentially. The key now is to find what the secret key is that is used to create the signature. For that, I found it hard-coded into SecretGenerator.java:

```java
package io.github.nandandesai.pico.security;

import io.github.nandandesai.pico.configs.UserDataPaths;
import io.github.nandandesai.pico.utils.FileOperation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.charset.Charset;

@Service
class SecretGenerator {
    private Logger logger = LoggerFactory.getLogger(SecretGenerator.class);
    private static final String SERVER_SECRET_FILENAME = "server_secret.txt";

    @Autowired
    private UserDataPaths userDataPaths;

    private String generateRandomString(int len) {
        // not so random
        return "1234"; // HERE IS THE KEY!!!
    }

    String getServerSecret() {
        try {
            String secret = new String(FileOperation.readFile(userDataPaths.getCurrentJarPath(), SERVER_SECRET_FILENAME), Charset.defaultCharset());
            logger.info("Server secret successfully read from the filesystem. Using the same for this runtime.");
            return secret;
        }catch (IOException e){
            logger.info(SERVER_SECRET_FILENAME+" file doesn't exists or something went wrong in reading that file. Generating a new secret for the server.");
            String newSecret = generateRandomString(32); // uh huh definitely random and not guessable...
            try {
                FileOperation.writeFile(userDataPaths.getCurrentJarPath(), SERVER_SECRET_FILENAME, newSecret.getBytes()); // the not-so-random string gets written into the secret server file anyway LMAO
            } catch (IOException ex) {
                ex.printStackTrace();
            }
            logger.info("Newly generated secret is now written to the filesystem for persistence.");
            return newSecret;
        }
    }
}
```

I then slapped all my information into [this JWT generator](https://jwt.io/) to forge the JWT. Then, I copied the forged JWT to replace that in the Chrome WebDev Tools, and then when I refreshed the page I became the admin. From there, I did what hint 4 suggested, opened the Flag book, and got the flag.

###Flag: picoCTF{w34k_jwt_n0t_g00d_d72df65e}

Solved by giggsterpuku
