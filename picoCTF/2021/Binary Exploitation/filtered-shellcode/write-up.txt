Challenge: filtered-shellcode
Category: Binary Exploitation
Description: A program that just runs the code you give it? That seems kinda boring... fun nc mercury.picoctf.net 16460
Hints:
	-1: Take a look at the calling convention and see how you might be able to setup all the registers

Obviously, this is a shellcode challenge, and obviously there seems to be a constraint to the shellcode we can supply. Looking at the binary in
Ghidra, the filter is implemented in a function called execute(), and it seems that it modifies out shellcode by doubling it and inserting some nop
assembly instructions every so often (this I tried to figure out, but at that point I looked up a write-up to look at; here's the link:
https://cyb3rwhitesnake.medium.com/picoctf-filtered-shellcode-pwn-3d69010376df). In addition, it adds a retq instruction at the end. I got hardstuck
on finding out the where the nop instructions are placed, so looking at the write-up and following it, I saw in dynamic analysis (and I went back
to figure it out in static analysis) that two are inserted for every two bytes of shellcode. Essentially, the constraint due to this is that the
assembly operations that I could do could only be one or two bytes long. Looking at the hint, I looked up how to call execve("/bin/sh", 0, 0)
using syscalls, and I found that there are 4 requirements: eax must have the value 11, ebx must hold a pointer to the "/bin/sh" string, and ecx and
edx must be zeroed out. Once they are set up, make the "int 80" instruction to make the syscall. From here, I tested out different instructions
using pwn.asm() to see which instructions would fit the 1/2-byte constraint, and I also found tips online to do that (ie XORing registers with
themselves, modifying the smaller, lower registers of the eax register). At first, I figured out how to set up eax, ecx, and edx, but the problem
came from how to set up ebx. I tried to do this by putting the "/bin/sh" string at the end of the shellcode and calulating an offset from where it
was on the stack to put its address into ebp, but that didn't work because the program thought it was just code. I then referred back to the
write-up, and I saw that the play the author used was writing to the bh and bl registers (lower registers of ebx) and bitwise shifting them up to be
the higher bytes so as to be able to write another 2 bytes to bh and bl. Then, he pushed them onto the stack so that the esp holds their address.
He/she did that twice so as to push the "/bin/sh" string in little endian onto the stack (32-bit binaries can only hold 4 bytes max in a register).
Once that was done, he set the ebx to have the address that esp held, and boom. I tried that, and I got shell.

Flag: picoCTF{th4t_w4s_fun_f1ed6f7952ff4071}
Solved by giggsterpuku in picoGym
